import React from 'react';

// This component is intentionally simple and does not sanitize input.
// It should only be used for content generated by the Gemini API,
// where we have instructed it to only use basic Markdown.

interface MarkdownRendererProps {
    content: string;
}

const MarkdownRenderer: React.FC<MarkdownRendererProps> = ({ content }) => {
    const elements: React.ReactNode[] = [];
    let currentList: React.ReactNode[] = [];

    const lines = content.split('\n');

    const flushList = (key: string | number) => {
        if (currentList.length > 0) {
            elements.push(<ul key={`ul-${key}`} className="list-disc list-inside space-y-1 my-2 pl-1">{currentList}</ul>);
            currentList = [];
        }
    };

    lines.forEach((line, index) => {
        const trimmedLine = line.trim();

        // Handle list items
        if (trimmedLine.startsWith('- ') || trimmedLine.startsWith('* ')) {
            const itemContent = trimmedLine.substring(2).replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
            currentList.push(<li key={`li-${index}`} dangerouslySetInnerHTML={{ __html: itemContent }} />);
            return;
        }

        // If we encounter a non-list line, flush any existing list.
        flushList(index);
        
        // Handle paragraphs
        if (trimmedLine.length > 0) {
             const pContent = line.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
             elements.push(<p key={`p-${index}`} dangerouslySetInnerHTML={{ __html: pContent }} />);
        }
    });
    
    // Flush any remaining list items at the end
    flushList('last');

    // If no complex elements were created, display with pre-wrap for streaming.
    if (elements.length === 0 && content) {
        return <div className="text-sm" style={{ whiteSpace: 'pre-wrap' }}>{content}</div>;
    }

    return (
        <div className="text-sm prose-sm max-w-none prose-strong:font-semibold">
            {elements}
        </div>
    );
};

export default MarkdownRenderer;
